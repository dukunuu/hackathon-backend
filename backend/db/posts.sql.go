// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: posts.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const approveVolunteer = `-- name: ApproveVolunteer :one
UPDATE post_volunteers SET status = 'approved', updated_at = CURRENT_TIMESTAMP WHERE post_id = $1 AND user_id = $2 RETURNING id, user_id, post_id, status, notes, created_at, updated_at
`

type ApproveVolunteerParams struct {
	PostID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) ApproveVolunteer(ctx context.Context, arg ApproveVolunteerParams) (PostVolunteer, error) {
	row := q.db.QueryRow(ctx, approveVolunteer, arg.PostID, arg.UserID)
	var i PostVolunteer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createCategory = `-- name: CreateCategory :one
INSERT INTO categories(name, description, endpoint, can_volunteer)
VALUES ($1, $2, $3, $4) RETURNING id, name, description, endpoint, can_volunteer, created_at, updated_at
`

type CreateCategoryParams struct {
	Name         string
	Description  pgtype.Text
	Endpoint     string
	CanVolunteer pgtype.Bool
}

func (q *Queries) CreateCategory(ctx context.Context, arg CreateCategoryParams) (Category, error) {
	row := q.db.QueryRow(ctx, createCategory,
		arg.Name,
		arg.Description,
		arg.Endpoint,
		arg.CanVolunteer,
	)
	var i Category
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.Endpoint,
		&i.CanVolunteer,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO posts (
    title,
    description,
    status,
    priority,
    preview_url,
    post_type,
    user_id,
    max_volunteers,
    current_volunteers,
    category_id,
    location_lat,
    location_lng,
    address_text
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
) RETURNING id, title, description, status, priority, preview_url, post_type, user_id, max_volunteers, current_volunteers, category_id, location_lat, location_lng, address_text, created_at, updated_at
`

type CreatePostParams struct {
	Title             string
	Description       string
	Status            PostStatus
	Priority          PostPriority
	PreviewUrl        pgtype.Text
	PostType          PostType
	UserID            pgtype.UUID
	MaxVolunteers     int32
	CurrentVolunteers int32
	CategoryID        pgtype.UUID
	LocationLat       pgtype.Float8
	LocationLng       pgtype.Float8
	AddressText       pgtype.Text
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, createPost,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.PreviewUrl,
		arg.PostType,
		arg.UserID,
		arg.MaxVolunteers,
		arg.CurrentVolunteers,
		arg.CategoryID,
		arg.LocationLat,
		arg.LocationLng,
		arg.AddressText,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.PreviewUrl,
		&i.PostType,
		&i.UserID,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.CategoryID,
		&i.LocationLat,
		&i.LocationLng,
		&i.AddressText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePost = `-- name: DeletePost :exec
DELETE FROM posts WHERE id = $1
`

func (q *Queries) DeletePost(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePost, id)
	return err
}

const deletePostVolunteer = `-- name: DeletePostVolunteer :exec
DELETE FROM post_volunteers WHERE post_id = $1 AND user_id = $2
`

type DeletePostVolunteerParams struct {
	PostID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) DeletePostVolunteer(ctx context.Context, arg DeletePostVolunteerParams) error {
	_, err := q.db.Exec(ctx, deletePostVolunteer, arg.PostID, arg.UserID)
	return err
}

const getCategories = `-- name: GetCategories :many
SELECT id, name, description, endpoint, can_volunteer, created_at, updated_at from categories
`

func (q *Queries) GetCategories(ctx context.Context) ([]Category, error) {
	rows, err := q.db.Query(ctx, getCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Category
	for rows.Next() {
		var i Category
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.Endpoint,
			&i.CanVolunteer,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getCategoryName = `-- name: GetCategoryName :one
SELECT name from categories WHERE id = $1
`

func (q *Queries) GetCategoryName(ctx context.Context, id pgtype.UUID) (string, error) {
	row := q.db.QueryRow(ctx, getCategoryName, id)
	var name string
	err := row.Scan(&name)
	return name, err
}

const getPost = `-- name: GetPost :one
SELECT
    p.id,
    p.title,
    p.description,
    p.status,
    p.priority,
    p.preview_url,
    p.post_type,
    p.user_id,
    p.max_volunteers,
    p.current_volunteers,
    p.category_id,
    p.location_lat,
    p.location_lng,
    p.address_text,
    p.created_at,
    p.updated_at,
    (
        SELECT json_agg(pi.image_url)
        FROM post_images pi
        WHERE pi.post_id = p.id
    ) AS images,
    (
        SELECT json_agg(pv.*)
        FROM post_volunteers pv
        WHERE pv.post_id = p.id
    ) AS volunteers
FROM posts p
WHERE p.id = $1
`

type GetPostRow struct {
	ID                pgtype.UUID
	Title             string
	Description       string
	Status            PostStatus
	Priority          PostPriority
	PreviewUrl        pgtype.Text
	PostType          PostType
	UserID            pgtype.UUID
	MaxVolunteers     int32
	CurrentVolunteers int32
	CategoryID        pgtype.UUID
	LocationLat       pgtype.Float8
	LocationLng       pgtype.Float8
	AddressText       pgtype.Text
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	Images            []byte
	Volunteers        []byte
}

func (q *Queries) GetPost(ctx context.Context, id pgtype.UUID) (GetPostRow, error) {
	row := q.db.QueryRow(ctx, getPost, id)
	var i GetPostRow
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.PreviewUrl,
		&i.PostType,
		&i.UserID,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.CategoryID,
		&i.LocationLat,
		&i.LocationLng,
		&i.AddressText,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Images,
		&i.Volunteers,
	)
	return i, err
}

const getUserPosts = `-- name: GetUserPosts :many
SELECT id, title, description, status, priority, preview_url, post_type, user_id, max_volunteers, current_volunteers, category_id, location_lat, location_lng, address_text, created_at, updated_at FROM posts WHERE user_id = $1 ORDER BY created_at DESC
`

func (q *Queries) GetUserPosts(ctx context.Context, userID pgtype.UUID) ([]Post, error) {
	rows, err := q.db.Query(ctx, getUserPosts, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.PreviewUrl,
			&i.PostType,
			&i.UserID,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.CategoryID,
			&i.LocationLat,
			&i.LocationLng,
			&i.AddressText,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserStats = `-- name: GetUserStats :one
SELECT
    (SELECT COUNT(*) FROM posts p WHERE p.user_id = $1) AS user_posts_count,
    (SELECT COUNT(*) FROM post_volunteers p_v WHERE p_v.user_id = $1) AS user_volunteer_count,
    (SELECT COUNT(*) FROM posts po WHERE po.user_id = $1 AND status = 'Шийдвэрлэгдсэн') AS approved_posts
`

type GetUserStatsRow struct {
	UserPostsCount     int64
	UserVolunteerCount int64
	ApprovedPosts      int64
}

func (q *Queries) GetUserStats(ctx context.Context, userID pgtype.UUID) (GetUserStatsRow, error) {
	row := q.db.QueryRow(ctx, getUserStats, userID)
	var i GetUserStatsRow
	err := row.Scan(&i.UserPostsCount, &i.UserVolunteerCount, &i.ApprovedPosts)
	return i, err
}

const listPostVolunteers = `-- name: ListPostVolunteers :many
SELECT id, user_id, post_id, status, notes, created_at, updated_at FROM post_volunteers ORDER BY created_at DESC
`

func (q *Queries) ListPostVolunteers(ctx context.Context) ([]PostVolunteer, error) {
	rows, err := q.db.Query(ctx, listPostVolunteers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PostVolunteer
	for rows.Next() {
		var i PostVolunteer
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.PostID,
			&i.Status,
			&i.Notes,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPosts = `-- name: ListPosts :many
SELECT
    p.id,
    p.title,
    p.description,
    p.status,
    p.priority,
    p.preview_url,
    p.post_type,
    p.user_id,
    p.max_volunteers,
    p.current_volunteers,
    p.category_id,
    p.location_lat,
    p.location_lng,
    p.address_text,
    p.created_at,
    p.updated_at,
    (
        SELECT json_agg(pi.image_url)
        FROM post_images pi
        WHERE pi.post_id = p.id
    ) AS images,
    (
        SELECT json_agg(pv.*)
        FROM post_volunteers pv
        WHERE pv.post_id = p.id
    ) AS volunteers
FROM posts p
ORDER BY p.created_at DESC
`

type ListPostsRow struct {
	ID                pgtype.UUID
	Title             string
	Description       string
	Status            PostStatus
	Priority          PostPriority
	PreviewUrl        pgtype.Text
	PostType          PostType
	UserID            pgtype.UUID
	MaxVolunteers     int32
	CurrentVolunteers int32
	CategoryID        pgtype.UUID
	LocationLat       pgtype.Float8
	LocationLng       pgtype.Float8
	AddressText       pgtype.Text
	CreatedAt         pgtype.Timestamptz
	UpdatedAt         pgtype.Timestamptz
	Images            []byte
	Volunteers        []byte
}

func (q *Queries) ListPosts(ctx context.Context) ([]ListPostsRow, error) {
	rows, err := q.db.Query(ctx, listPosts)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListPostsRow
	for rows.Next() {
		var i ListPostsRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Status,
			&i.Priority,
			&i.PreviewUrl,
			&i.PostType,
			&i.UserID,
			&i.MaxVolunteers,
			&i.CurrentVolunteers,
			&i.CategoryID,
			&i.LocationLat,
			&i.LocationLng,
			&i.AddressText,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Images,
			&i.Volunteers,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const rejectVolunteer = `-- name: RejectVolunteer :one
UPDATE post_volunteers SET status = 'rejected', updated_at = CURRENT_TIMESTAMP WHERE post_id = $1 AND user_id = $2 RETURNING id, user_id, post_id, status, notes, created_at, updated_at
`

type RejectVolunteerParams struct {
	PostID pgtype.UUID
	UserID pgtype.UUID
}

func (q *Queries) RejectVolunteer(ctx context.Context, arg RejectVolunteerParams) (PostVolunteer, error) {
	row := q.db.QueryRow(ctx, rejectVolunteer, arg.PostID, arg.UserID)
	var i PostVolunteer
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PostID,
		&i.Status,
		&i.Notes,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePost = `-- name: UpdatePost :one
UPDATE posts SET
    title = COALESCE($2, title),
    description = COALESCE($3, description),
    status = COALESCE($4, status),
    priority = COALESCE($5, priority),
    preview_url = COALESCE($6, preview_url),
    post_type = COALESCE($7, post_type),
    user_id = COALESCE($8, user_id),
    max_volunteers = COALESCE($9, max_volunteers),
    current_volunteers = COALESCE($10, current_volunteers),
    category_id = COALESCE($11, category_id),
    location_lat = COALESCE($12, location_lat),
    location_lng = COALESCE($13, location_lng),
    address_text = COALESCE($14, address_text),
    updated_at = CURRENT_TIMESTAMP
WHERE id = $1
RETURNING id, title, description, status, priority, preview_url, post_type, user_id, max_volunteers, current_volunteers, category_id, location_lat, location_lng, address_text, created_at, updated_at
`

type UpdatePostParams struct {
	ID                pgtype.UUID
	Title             string
	Description       string
	Status            PostStatus
	Priority          PostPriority
	PreviewUrl        pgtype.Text
	PostType          PostType
	UserID            pgtype.UUID
	MaxVolunteers     int32
	CurrentVolunteers int32
	CategoryID        pgtype.UUID
	LocationLat       pgtype.Float8
	LocationLng       pgtype.Float8
	AddressText       pgtype.Text
}

func (q *Queries) UpdatePost(ctx context.Context, arg UpdatePostParams) (Post, error) {
	row := q.db.QueryRow(ctx, updatePost,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Status,
		arg.Priority,
		arg.PreviewUrl,
		arg.PostType,
		arg.UserID,
		arg.MaxVolunteers,
		arg.CurrentVolunteers,
		arg.CategoryID,
		arg.LocationLat,
		arg.LocationLng,
		arg.AddressText,
	)
	var i Post
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Status,
		&i.Priority,
		&i.PreviewUrl,
		&i.PostType,
		&i.UserID,
		&i.MaxVolunteers,
		&i.CurrentVolunteers,
		&i.CategoryID,
		&i.LocationLat,
		&i.LocationLng,
		&i.AddressText,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
